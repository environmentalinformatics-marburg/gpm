---
title: "Vignette Title"
author: "Vignette Author"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

## Preprocessing 
The `orthoptera` dataset provides species prevalence information along with
spatial and temporal closeley correlated MODIS information.
```{r, fig.show='hold'}
data(orthoptera)
str(orthoptera)
col_meta <- seq(1, 13)
col_species <- seq(14, 178)
col_modis <- seq(179, 216)

# hist(orthoptera$plot, breaks = 116)
# sort(unique(orthoptera$plot))

# Select species which occure at least on 20 unique plots on average -----------
plotid <- orthoptera$plot
observations <- orthoptera[, col_species]
speciesnames <- meanOccupancy(plotid, observations, 
                              resample = 100, thv = 20)
# devtools::use_data(speciesnames, overwrite = TRUE)
orth_sub <- orthoptera[, c(col_meta, 
                           which(colnames(orthoptera) %in% speciesnames),
                           col_modis)]


# Compile dataset containing complete cases only -------------------------------
summary(orth_sub)
orth_sub <- orth_sub[, -(which(colnames(orth_sub) == "greyval_band_11") : 
                           which(colnames(orth_sub) == "greyval_band_16"))]
# any(is.na(orth_sub[, -7]))
# devtools::use_data(orth_sub, overwrite = TRUE)
```

## Create model evaluation dataset 
```{r, fig.show='hold'}
for(i in seq(14, 34)){
  temp <- as.character(orth_sub[, i])
  temp[temp == "0"] <- "no"
  temp[temp == "1"] <- "yes"
  orth_sub[, i] <- as.factor(temp)
}

orth_smpl <- conditionalSample(orth_sub[, -(2:13)], orth_sub$plot, 
                               resample = 100)
# devtools::use_data(orth_smpl, overwrite = TRUE)


# Split dataset into testing and training samples
response <- seq(2,22)
orth_smpl_split <- splitByFrequency(orth_smpl, response)
# devtools::use_data(orth_smpl_split, overwrite = TRUE)
```

## Prediction
```{r, fig.show='hold'}
response <- 2
independent <- seq(3, 32)


models <- lapply(seq(100), function(x){
  act <- orth_smpl_split[[1]][[x]]
  act_train <- act$training
  act_test <- act$test
  
  # # Convert response variables to factors
  # act_train[, response] <- as.factor(act_train[, response])
  # act_test[, response] <- as.factor(act_test[, response])
  # 
  # resp2 <- act_train[, response]
  # resp <- rep("no", length(resp2))
  # resp[resp2 == "1"] <- "yes"
  # resp <- as.factor(resp)
  
  resp <- act_train[, response]
  indp <- act_train[, independent]
  
  set.seed(10)
  cv_splits <- createFolds(resp, k=5, returnTrain = TRUE)
  
  # thresholds=c(seq(0.0, 0.40, 0.02),seq(0.50,1,0.1))
  # summaryFunction = "fourStats"
  
  rfeCntrl <- rfeControl(functions = caretFuncs,
                         method="cv", index = cv_splits,
                         returnResamp = "all",
                         verbose = FALSE,
                         rerank=FALSE)
  
  trCntr <- trainControl(method="cv", number = 5, repeats = 1, verbose = FALSE)
  
  n_var <- seq(2, ncol(indp), 8)
  
  
  # method = rf_thvs
  # 
  #   ctrl <- trainControl(index=cvSplits,
  #                        method="cv",
  #                        summaryFunction = eval(parse(text=summaryFunction)),
  #                        classProbs = classProbs)
  
  rfe_model <- rfe(indp, resp,
                   metric = "Accuracy", method = "rf", 
                   sizes = n_var,
                   rfeControl = rfeCntrl,
                   trControl = trCntr, verbose = FALSE,
                   tuneGrid = expand.grid(mtry = n_var))
  
  return(rfe_model)
  })

# devtools::use_data(models, overwrite = TRUE)
# load(models)
# load(orth_smpl_split)


plot(varImp(rfe_model$fit,scale=TRUE))

test <- lapply(seq(100), function(x){
  act_test <- predict(models[[x]], orth_smpl_split[[1]][[x]]$test[, independent])
  act_obs <- orth_smpl_split[[1]][[x]]$test[, response]
  calcKappa(ftable(data.frame(PREDICT = act_test$pred, OBSERVERD = act_obs)))[1]
})
summary(unlist(test))
```



















Vignettes are long form documentation commonly included in packages. Because they are part of the distribution of the package, they need to be as compact as possible. The `html_vignette` output type provides a custom style sheet (and tweaks some options) to ensure that the resulting html is as small as possible. The `html_vignette` format:

- Never uses retina figures
- Has a smaller default figure size
- Uses a custom CSS stylesheet instead of the default Twitter Bootstrap style

## Vignette Info

Note the various macros within the `vignette` setion of the metadata block above. These are required in order to instruct R how to build the vignette. Note that you should change the `title` field and the `\VignetteIndexEntry` to match the title of your vignette.

## Styles

The `html_vignette` template includes a basic CSS theme. To override this theme you can specify your own CSS in the document metadata as follows:

    output: 
      rmarkdown::html_vignette:
        css: mystyles.css

## Figures

The figure sizes have been customised so that you can easily put two images side-by-side. 

```{r, fig.show='hold'}
plot(1:10)
plot(10:1)
```

You can enable figure captions by `fig_caption: yes` in YAML:

    output:
      rmarkdown::html_vignette:
        fig_caption: yes

Then you can use the chunk option `fig.cap = "Your figure caption."` in **knitr**.

## More Examples

You can write math expressions, e.g. $Y = X\beta + \epsilon$, footnotes^[A footnote here.], and tables, e.g. using `knitr::kable()`.

```{r, echo=FALSE, results='asis'}
knitr::kable(head(mtcars, 10))
```

Also a quote using `>`:

> "He who gives up [code] safety for [code] speed deserves neither."
([via](https://twitter.com/hadleywickham/status/504368538874703872))
